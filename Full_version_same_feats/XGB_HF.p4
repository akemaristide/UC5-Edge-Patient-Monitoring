########################################################################
# THIS FILE IS PART OF Planter PROJECT
# Copyright (c) Changgang Zheng and Computing Infrastructure Group
# Department of Engineering Science, University of Oxford
# All rights reserved.
# E-mail: changgang.zheng@eng.ox.ac.uk or changgangzheng@qq.com
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at :
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#########################################################################
# This file was autogenerated

/*
 * Planter
 *
 * This program implements a simple protocol. It can be carried over Ethernet
 * (Ethertype 0x1234).
 *
 * The Protocol header looks like this:
 *
 *        0                1                  2              3
 * +----------------+----------------+----------------+---------------+
 * |      P         |       4        |     Version    |     Type      |
 * +----------------+----------------+----------------+---------------+
 * |                              feature0                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature1                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature2                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature3                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature4                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature5                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature6                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature7                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature8                            |
 * +----------------+----------------+----------------+---------------+
 * |                              feature9                            |
 * +----------------+----------------+----------------+---------------+
 * |                              Result                              |
 * +----------------+----------------+----------------+---------------+
 *
 * P is an ASCII Letter 'P' (0x50)
 * 4 is an ASCII Letter '4' (0x34)
 * Version is currently 1 (0x01)
 * Type is currently 1 (0x01)
 *
 * The device receives a packet, do the classification, fills in the
 * result and sends the packet back out of the same port it came in on, while
 * swapping the source and destination addresses.
 *
 * If an unknown operation is specified or the header is not valid, the packet
 * is dropped
 */

#include <core.p4>
#include <v1model.p4>

/*************************************************************************
*********************** headers and metadata *****************************
*************************************************************************/

const bit<16> ETHERTYPE_Planter = 0x1234;
const bit<8>  Planter_P     = 0x50;   // 'P'
const bit<8>  Planter_4     = 0x34;   // '4'
const bit<8>  Planter_VER   = 0x01;   // v0.1

header ethernet_h {
    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header Planter_h{
    bit<8> p;
    bit<8> four;
    bit<8> ver;
    bit<8> typ;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> feature5;
    bit<32> feature6;
    bit<32> feature7;
    bit<32> feature8;
    bit<32> feature9;
    bit<32> result;
}

struct header_t {
    ethernet_h   ethernet;
    Planter_h    Planter;
}

struct metadata_t {
    bit<6> code_f0_hf;
    bit<6> code_f1_hf;
    bit<4> code_f2_hf;
    bit<2> code_f3_hf;
    bit<6> code_f4_hf;
    bit<2> code_f5_hf;
    bit<4> code_f6_hf;
    bit<6> code_f7_hf;
    bit<10> code_f8_hf;
    bit<4> code_f9_hf;
    bit<7> sum_prob_hf;
    bit<4> tree_0_vote_hf;
    bit<4> tree_1_vote_hf;
    bit<7> tree_0_prob_hf;
    bit<7> tree_1_prob_hf;
    bit<32>  DstAddr;
    bit<16> temperature;
    bit<16> oxygen_saturation;
    bit<16> pulse_rate;
    bit<16> systolic_bp;
    bit<16> respiratory_rate;
    bit<16> avpu;
    bit<16> supplemental_oxygen;
    bit<16> referral_source; 
    bit<8>  age; 
    bit<8>  sex;
    bit<32> feature0;
    bit<32> feature1;
    bit<32> feature2;
    bit<32> feature3;
    bit<32> feature4;
    bit<32> feature5;
    bit<32> feature6;
    bit<32> feature7;
    bit<32> feature8;
    bit<32> feature9;
    bit<32> result;
    bit<32> result_hf;
    bit<8> flag ;
}

/*************************************************************************
*********************** Ingress Parser ***********************************
*************************************************************************/

parser SwitchParser(
    packet_in pkt,
    out header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    state start {
        transition parse_ethernet;
    }

    state parse_ethernet {
        pkt.extract(hdr.ethernet);
        transition select(hdr.ethernet.etherType) {
        ETHERTYPE_Planter : check_planter_version;
        default           : accept;
        }
    }

    state check_planter_version {
        transition select(pkt.lookahead<Planter_h>().p,
                          pkt.lookahead<Planter_h>().four,
                          pkt.lookahead<Planter_h>().ver) {
        (Planter_P, Planter_4, Planter_VER) : parse_planter;
        default                             : accept;
        }
    }

    state parse_planter {
        pkt.extract(hdr.Planter);
        meta.feature0 = hdr.Planter.feature0;
        meta.feature1 = hdr.Planter.feature1;
        meta.feature2 = hdr.Planter.feature2;
        meta.feature3 = hdr.Planter.feature3;
        meta.feature4 = hdr.Planter.feature4;
        meta.feature5 = hdr.Planter.feature5;
        meta.feature6 = hdr.Planter.feature6;
        meta.feature7 = hdr.Planter.feature7;
        meta.feature8 = hdr.Planter.feature8;
        meta.feature9 = hdr.Planter.feature9;
        meta.flag = 1 ;
        transition accept;
    }
}

/*************************************************************************
*********************** Egress Deparser *********************************
**************************************************************************/

control SwitchDeparser(
    packet_out pkt,
    in header_t hdr) {
    apply {
        pkt.emit(hdr);
    }
}

/*************************************************************************
********************** Checksum Verification *****************************
*************************************************************************/

control SwitchVerifyChecksum(inout header_t hdr,
                       inout metadata_t meta) {
    apply {}
}
/*************************************************************************
********************** Checksum Computation ******************************
*************************************************************************/

control SwitchComputeChecksum(inout header_t hdr,
                        inout metadata_t meta) {
    apply {}
}
/*************************************************************************
*********************** Ingress Processing********************************
**************************************************************************/

control SwitchIngress(
    inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t ig_intr_md) {

    action send(bit<9> port) {
        ig_intr_md.egress_spec = port;
    }

    action drop() {
        mark_to_drop(ig_intr_md);
    }

    // Prepare features for inference if Planter packet
    action prepare_planter_feats_hf(){
        meta.temperature         = (bit<16>)hdr.Planter.feature0;
        meta.oxygen_saturation   = (bit<16>)hdr.Planter.feature1;
        meta.pulse_rate          = (bit<16>)hdr.Planter.feature2;
        meta.systolic_bp         = (bit<16>)hdr.Planter.feature3;
        meta.respiratory_rate    = (bit<16>)hdr.Planter.feature4;
        meta.avpu                = (bit<16>)hdr.Planter.feature5;
        meta.supplemental_oxygen = (bit<16>)hdr.Planter.feature6;
        meta.referral_source     = (bit<16>)hdr.Planter.feature7;
        meta.age                 = (bit<8>)hdr.Planter.feature8;
        meta.sex                 = (bit<8>)hdr.Planter.feature9;
    }

    action extract_feature0_hf(out bit<6> meta_code, bit<6> tree){
        meta_code = tree;
    }

    action extract_feature1_hf(out bit<6> meta_code, bit<6> tree){
        meta_code = tree;
    }

    action extract_feature2_hf(out bit<4> meta_code, bit<4> tree){
        meta_code = tree;
    }

    action extract_feature3_hf(out bit<2> meta_code, bit<2> tree){
        meta_code = tree;
    }

    action extract_feature4_hf(out bit<6> meta_code, bit<6> tree){
        meta_code = tree;
    }

    action extract_feature5_hf(out bit<2> meta_code, bit<2> tree){
        meta_code = tree;
    }

    action extract_feature6_hf(out bit<4> meta_code, bit<4> tree){
        meta_code = tree;
    }

    action extract_feature7_hf(out bit<6> meta_code, bit<6> tree){
        meta_code = tree;
    }

    action extract_feature8_hf(out bit<10> meta_code, bit<10> tree){
        meta_code = tree;
    }

    action extract_feature9_hf(out bit<4> meta_code, bit<4> tree){
        meta_code = tree;
    }

    @pragma stage 0
    table lookup_feature0_hf {
        key = { meta.temperature:ternary; }
        actions = {
            extract_feature0_hf(meta.code_f0_hf);
            NoAction;
            }
        size = 17;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature1_hf {
        key = { meta.oxygen_saturation:ternary; }
        actions = {
            extract_feature1_hf(meta.code_f1_hf);
            NoAction;
            }
        size = 14;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature2_hf {
        key = { meta.pulse_rate:ternary; }
        actions = {
            extract_feature2_hf(meta.code_f2_hf);
            NoAction;
            }
        size = 13;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature3_hf {
        key = { meta.systolic_bp:ternary; }
        actions = {
            extract_feature3_hf(meta.code_f3_hf);
            NoAction;
            }
        size = 9;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature4_hf {
        key = { meta.respiratory_rate:ternary; }
        actions = {
            extract_feature4_hf(meta.code_f4_hf);
            NoAction;
            }
        size = 10;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature5_hf {
        key = { meta.avpu:ternary; }
        actions = {
            extract_feature5_hf(meta.code_f5_hf);
            NoAction;
            }
        size = 1;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature6_hf {
        key = { meta.supplemental_oxygen:ternary; }
        actions = {
            extract_feature6_hf(meta.code_f6_hf);
            NoAction;
            }
        size = 2;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature7_hf {
        key = { meta.referral_source:ternary; }
        actions = {
            extract_feature7_hf(meta.code_f7_hf);
            NoAction;
            }
        size = 3;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature8_hf {
        key = { meta.age:ternary; }
        actions = {
            extract_feature8_hf(meta.code_f8_hf);
            NoAction;
            }
        size = 26;
        default_action = NoAction;
    }

    @pragma stage 0
    table lookup_feature9_hf {
        key = { meta.sex:ternary; }
        actions = {
            extract_feature9_hf(meta.code_f9_hf);
            NoAction;
            }
        size = 2;
        default_action = NoAction;
    }


    action read_prob0_hf(bit<7> prob, bit<4> vote){
        meta.tree_0_prob_hf = prob;
        meta.tree_0_vote_hf = vote;
    }
    action write_default_class0_hf() {
        meta.tree_0_vote_hf = 8;
    }


    action read_prob1_hf(bit<7> prob, bit<4> vote){
        meta.tree_1_prob_hf = prob;
        meta.tree_1_vote_hf = vote;
    }
    action write_default_class1_hf() {
        meta.tree_1_vote_hf = 8;
    }

    @pragma stage 1
    table lookup_leaf_id0_hf {
        key = { meta.code_f0_hf[2:0]:exact;
                meta.code_f1_hf[2:0]:exact;
                meta.code_f2_hf[1:0]:exact;
                meta.code_f3_hf[0:0]:exact;
                meta.code_f4_hf[2:0]:exact;
                meta.code_f5_hf[0:0]:exact;
                meta.code_f6_hf[1:0]:exact;
                meta.code_f7_hf[2:0]:exact;
                meta.code_f8_hf[4:0]:exact;
                meta.code_f9_hf[1:0]:exact;
                }
        actions={
            read_prob0_hf;
            write_default_class0_hf;
        }
        size = 4680;
        default_action = write_default_class0_hf;
    }

    @pragma stage 1
    table lookup_leaf_id1_hf {
        key = { meta.code_f0_hf[5:3]:exact;
                meta.code_f1_hf[5:3]:exact;
                meta.code_f2_hf[3:2]:exact;
                meta.code_f3_hf[1:1]:exact;
                meta.code_f4_hf[5:3]:exact;
                meta.code_f5_hf[1:1]:exact;
                meta.code_f6_hf[3:2]:exact;
                meta.code_f7_hf[5:3]:exact;
                meta.code_f8_hf[9:5]:exact;
                meta.code_f9_hf[3:2]:exact;
                }
        actions={
            read_prob1_hf;
            write_default_class1_hf;
        }
        size = 8496;
        default_action = write_default_class1_hf;
    }

    action read_lable_hf(bit<32> label){
        meta.result_hf = label;
    }

    action write_default_decision_hf() {
        meta.result_hf = 0;
    }

    table decision_hf {
        key = { meta.tree_0_vote_hf:exact;
                meta.tree_1_vote_hf:exact;
                }
        actions={
            read_lable_hf;
            write_default_decision_hf;
        }
        size = 46;
        default_action = write_default_decision_hf;
    }

    apply{
        prepare_planter_feats_hf();
        lookup_feature0_hf.apply();
        lookup_feature1_hf.apply();
        lookup_feature2_hf.apply();
        lookup_feature3_hf.apply();
        lookup_feature4_hf.apply();
        lookup_feature5_hf.apply();
        lookup_feature6_hf.apply();
        lookup_feature7_hf.apply();
        lookup_feature8_hf.apply();
        lookup_feature9_hf.apply();
        lookup_leaf_id0_hf.apply();
        lookup_leaf_id1_hf.apply();
        decision_hf.apply();
        hdr.Planter.result = meta.result_hf;
        send(ig_intr_md.ingress_port);
    }
}
/*************************************************************************
*********************** egress Processing********************************
**************************************************************************/

control SwitchEgress(inout header_t hdr,
    inout metadata_t meta,
    inout standard_metadata_t eg_intr_md) {
    apply {
    }
}
/*************************************************************************
***********************  S W I T C H  ************************************
*************************************************************************/

V1Switch(
    SwitchParser(),
    SwitchVerifyChecksum(),
    SwitchIngress(),
    SwitchEgress(),
    SwitchComputeChecksum(),
    SwitchDeparser()
) main;